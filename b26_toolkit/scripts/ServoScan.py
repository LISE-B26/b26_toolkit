import numpy as np
import time
from pylabcontrol.core import Script, Parameter
from b26_toolkit.instruments import B26KDC001x, B26KDC001z, B26KDC001y
from b26_toolkit.scripts.find_nv import FindNV
from b26_toolkit.scripts.daq_read_counter import Daq_Read_Counter
from b26_toolkit.plotting.plots_1d import plot_counts_vs_pos
from collections import deque
import scipy as sp

class ServoScan(Script):
    """
    ServoScan sweeps the position of the automatic translation stages, in 1D scans, and records NV fluorescence
    using Daq_Read_Counter, at each point in the scan.

    We use the NV fluorescence to align a magnetic bias field to the NV axis, generated by a permanent magnet.

    ER 20180606

    """

    _DEFAULT_SETTINGS = [
        Parameter('track_n_pts', 10, int, 'track every N points'),
        Parameter('scan_axis', 'x', ['x', 'y', 'z'], 'axis to scan on'),
        Parameter('num_points', 100, int, 'number of points in the scan'),
        Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
        Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
        Parameter('time_per_pt', 0.5, float, 'time to wait at each point (s)')
        ]

    _INSTRUMENTS = {'XServo': B26KDC001x, 'YServo': B26KDC001y, 'ZServo': B26KDC001z}

    _SCRIPTS = {'find_nv': FindNV, 'daq_read_counter': Daq_Read_Counter}

    def _get_instr(self):
        """

        Assigns an instrument relevant to the 1D scan axis.

        """
        if self.settings['scan_axis'] == 'x':
            return self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'y':
            return self.instruments['YServo']['instance']
        elif self.settings['scan_axis'] == 'z':
            return self.instruments['ZServo']['instance']

    def _get_scan_positions(self, verbose=True):
        '''
        Returns an array of points to go to in the 1D scan.
        '''
        if self.settings['scan_axis'] in ['x', 'y', 'z']:
            scan_pos = [np.linspace(self.settings['min_pos'], self.settings['max_pos'], self.settings['num_points'])]

            if verbose:
                print('values for the scan are (in mm):', scan_pos)

            return scan_pos
        else:
            NotImplementedError('multiple dimensional scans not yet implemented')

    def gaussian(self, x, noise, amp, center, width):
        return (noise + amp * np.exp(-1.0 * (np.square((x - center)) / (2 * (width ** 2)))))

    def fit_gaussian(self):
        noise_guess = np.min(self.data['counts'])
        amplitude_guess = np.max(self.data['counts']) - noise_guess
        center_guess = np.mean(self.data['positions'])
        width_guess = np.std(self.data['positions'])

        p2 = [noise_guess, amplitude_guess, center_guess, width_guess]

        pos_of_max = None

        print('trying to fit the gaussian!')

        try:
            p2, success = sp.optimize.curve_fit(self.gaussian, self.data['positions'],
                                                self.data['counts'], p0=p2,
                                                bounds=([0, [np.inf, np.inf, 100., 100.]]), max_nfev=2000)

            print('p2', p2)
            print('success', success)

            pos_of_max = p2[2]

            self.log('Found fit parameters: ' + str(p2))
        except(ValueError, RuntimeError):
            self.log('Could not converge to fit parameters')

        return pos_of_max, p2

    def _function(self):

        # get the relevant instrument.
        scan_instr = self._get_instr()

        # get positions for the scan.
        scan_pos = self._get_scan_positions()

        # data structure
        self.data = {'counts': deque()}
        self.positions = {'positions': deque()}

        # place for fit parameters
        self.data['fit_parameters'] = [0, 0, 0, 0]
        self.data['positions'] = scan_pos

        # loop over scan positions and call the scripts
        for index in range(0, self.settings['num_points']):
            if self._abort:
                break

            new_pos = float(scan_pos[0][index])
            scan_instr.settings['position'] = new_pos # update the position setting of the instrument
            scan_instr.set_position() # actually move the instrument to that location. If this is not within the safety
                                      # limits of the instruments, it will not actually move and say so in the log

            # run daq_read_counter or the relevant script to get fluorescence
            self.scripts['daq_read_counter'].run()
            time.sleep(self.settings['time_per_pt'])
            self.scripts['daq_read_counter'].stop()

            # add to output structures which will be plotted
            data = self.scripts['daq_read_counter'].data['counts']
            self.data['counts'].append(np.mean(data))
            self.positions['positions'].append(new_pos)

            self.progress = index*100./self.settings['num_points']
            self.updateProgress.emit(int(self.progress))


            # track to the NV
            if index > 0 and index % self.settings['track_n_pts'] == 0:
                self.scripts['find_nv'].run()

        # clean up data, as in daq_read_counter
        self.data['counts'] = list(self.data['counts'])

        # attempt to fit
        pos_of_max, self.data['fit_parameters'] = self.fit_gaussian()
        if pos_of_max:
            print('found maximum fluorescence position at: ', pos_of_max, ' mm')



    def plot(self, figure_list):
        super(ServoScan, self).plot([figure_list[0]])

    def _plot(self, axes_list, data = None):
        # COMMENT_ME

        if data is None:
            data = self.data

        if data:
            plot_counts_vs_pos(axes_list[0], data['counts'], self.positions['positions'])

        # if the fit has finished plot the result
        if not (np.array_equal(data['fit_parameters'], [0, 0, 0, 0])):
            axes_list[0].plot(data['positions'],
                            self.gaussian(data['positions'], *self.data['fit_parameters']), 'k')


# import numpy as np
#
# from pylabcontrol.core import Script, Parameter
# from b26_toolkit.instruments import KDC001
# from b26_toolkit.scripts import GalvoScan, ESR
#


# ER: this is the old version - delete in the future
# class ServoScan(Script):
#     """
#     GalvoScan uses the apd, daq, and galvo to sweep across voltages while counting photons at each voltage,
#     resulting in an image in the current field of view of the objective.
#     """
#
#     _DEFAULT_SETTINGS = [
#         Parameter('loop_script', 'GalvoScan', ['GalvoScan', 'ESR'], 'Script to execute at each servo position'),
#         Parameter('channel1',
#                   [Parameter('axis', 'z', ['None', 'x', 'y', 'z', 'xy', 'xz', 'yz'], 'axis to scan on'),
#                    Parameter('min_value', 0.0, float, 'starting point of scan'),
#                    Parameter('max_value', 1.0, float, 'ending point of scan'),
#                    Parameter('num_points', 10, int, 'number of points for scan'),
#                    Parameter('min_value2', 0.0, float, 'starting point of scan (second dimension)'),
#                    Parameter('max_value2', 1.0, float, 'ending point of scan (second dimension)'),
#                    Parameter('num_points2', 10, int, 'number of points for scan (second dimension)')
#                   ]),
#         Parameter('channel2',
#                   [Parameter('axis', 'y', ['None', 'x', 'y', 'z', 'xy', 'xz', 'yz'], 'axis to scan on'),
#                    Parameter('min_value', 0.0, float, 'starting point of scan'),
#                    Parameter('max_value', 1.0, float, 'ending point of scan'),
#                    Parameter('num_points', 10, int, 'number of points for scan'),
#                    Parameter('min_value2', 0.0, float, 'starting point of scan (second dimension)'),
#                    Parameter('max_value2', 1.0, float, 'ending point of scan (second dimension)'),
#                    Parameter('num_points2', 10, int, 'number of points for scan (second dimension)')
#                    ]),
#         Parameter('channel3',
#                   [Parameter('axis', 'x', ['None', 'x', 'y', 'z', 'xy', 'xz', 'yz'], 'axis to scan on'),
#                    Parameter('min_value', 0.0, float, 'starting point of scan'),
#                    Parameter('max_value', 1.0, float, 'ending point of scan'),
#                    Parameter('num_points', 10, int, 'number of points for scan'),
#                    Parameter('min_value2', 0.0, float, 'starting point of scan (second dimension)'),
#                    Parameter('max_value2', 1.0, float, 'ending point of scan (second dimension)'),
#                    Parameter('num_points2', 10, int, 'number of points for scan (second dimension)')
#                    ])
#     ]
#
#     _INSTRUMENTS = {'XServo': KDC001, 'YServo': KDC001, 'ZServo': KDC001}
#
#     _SCRIPTS = {'GalvoScan': GalvoScan, 'ESR': ESR}
#
#     def _function(self):
#         def _get_channel(channel_name):
#             if self.settings[channel_name]['axis'] == 'None':
#                 return None, None
#             elif self.settings[channel_name]['axis'] == 'x':
#                 return self.instruments['XServo'], None
#             elif self.settings[channel_name]['axis'] == 'y':
#                 return self.instruments['YServo'], None
#             elif self.settings[channel_name]['axis'] == 'z':
#                 return self.instruments['ZServo'], None
#             elif self.settings[channel_name]['axis'] == 'xy':
#                 return self.instruments['XServo'], self.instruments['YServo']
#             elif self.settings[channel_name]['axis'] == 'xz':
#                 return self.instruments['XServo'], self.instruments['ZServo']
#             elif self.settings[channel_name]['axis'] == 'yz':
#                 return self.instruments['YServo'], self.instruments['ZServo']
#
#         def _get_channel_positions(channel_name):
#             if self.settings[channel_name]['axis'] == 'None':
#                 return([0], None)
#             elif self.settings[channel_name]['axis'] in ['x', 'y', 'z']:
#                 return([np.linspace(self.settings['min_value'], self.settings['max_value'], self.settings['num_points'])], None)
#             elif self.settings[channel_name]['axis'] in ['xy', 'xz', 'yz']:
#                 return([np.linspace(self.settings['min_value'], self.settings['max_value'], self.settings['num_points'])],
#                       [np.linspace(self.settings['min_value2'], self.settings['max_value2'], self.settings['num_points2'])])
#
#         channel1_servos = _get_channel('channel1')
#         channel2_servos = _get_channel('channel2')
#         channel3_servos = _get_channel('channel3')
#
#         channel1_pos, channel1_pos2 = _get_channel_positions(self.settings['channel_1']['axis'])
#         channel2_pos, channel2_pos2 = _get_channel_positions(self.settings['channel_2']['axis'])
#         channel3_pos, channel3_pos2 = _get_channel_positions(self.settings['channel_3']['axis'])
#
#         for index, pos1 in enumerate(channel1_pos):
#             channel1_servos[0].position = pos1
#             if channel1_servos[1]:
#                 channel1_servos[1].position = channel1_pos2[index]
#             for index, pos2 in enumerate(channel2_pos):
#                 channel2_servos[0].position = pos2
#                 if channel2_servos[1]:
#                     channel2_servos[1].position = channel2_pos2[index]
#                 for index, pos3 in enumerate(channel3_pos):
#                     channel3_servos[0].position = pos3
#                     if channel3_servos[1]:
#                         channel3_servos[1].position = channel3_pos2[index]
#                         script = self.settings['loop_script']
#                         script.settings['tag'] = script.settings['tag'] + '_' + str(pos1) + '_' + str(pos2) + '_' + str(pos3)
#                         self.scripts[self.settings['loop_script']].run()

if __name__ == '__main__':
    succeeded, failed, _ = Script.load_and_append({'ServoScan': ServoScan})

    print(succeeded)