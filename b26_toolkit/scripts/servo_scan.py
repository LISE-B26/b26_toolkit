import numpy as np
import time
from collections import deque
import scipy as sp
from pylabcontrol.core import Script, Parameter
from b26_toolkit.instruments import B26KDC001x, B26KDC001z, B26KDC001y, NI9219, NI9215
from b26_toolkit.scripts.find_nv import FindNv
from b26_toolkit.scripts.daq_read_counter import DaqReadCounterOld
from b26_toolkit.scripts.daq_read_ai import Daq_Read_Analog
from b26_toolkit.scripts.autofocus import AutoFocusDaqMDT693A, AutoFocusDAQMax
from b26_toolkit.scripts.esr import EsrSimple
from b26_toolkit.plotting.plots_1d import plot_counts_vs_pos, update_counts_vs_pos
from b26_toolkit.plotting.plots_2d import plot_fluorescence_pos, update_fluorescence, plot_fluorescence_new


class ServoScan(Script):
    """
    ServoScan sweeps the position of the automatic translation stages, in 1D scans, and records NV fluorescence
    using Daq_Read_Counter, at each point in the scan.
    We use the NV fluorescence to align a magnetic bias field to the NV axis, generated by a permanent magnet.
    """

    _DEFAULT_SETTINGS = [
        Parameter('track_n_pts', 10, int, 'track every N points'),
        Parameter('scan_axis', 'x', ['x', 'y', 'z'], 'axis to scan on'),
        Parameter('num_points', 100, int, 'number of points in the scan'),
        Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
        Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
        Parameter('time_per_pt', 0.5, float, 'time to wait at each point (s)'),
        Parameter('use_autofocus', True, bool, 'check to enable autofocus during tracking'),
        Parameter('track_to_nv', False, bool, 'check to use find_nv to track to the NV')
        ]

    _INSTRUMENTS = {'XServo': B26KDC001x, 'YServo': B26KDC001y, 'ZServo': B26KDC001z}
    _SCRIPTS = {'find_nv': FindNv, 'daq_read_counter': DaqReadCounterOld}

    def _get_instr(self):
        """
        Assigns an instrument relevant to the 1D scan axis.
        """
        if self.settings['scan_axis'] == 'x':
            return self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'y':
            return self.instruments['YServo']['instance']
        elif self.settings['scan_axis'] == 'z':
            return self.instruments['ZServo']['instance']

    def _get_scan_positions(self, verbose=True):
        """
        Returns an array of points to go to in the 1D scan.
        """

        if self.settings['scan_axis'] in ['x', 'y', 'z']:
            scan_pos = [np.linspace(self.settings['min_pos'], self.settings['max_pos'], self.settings['num_points'])]

            if verbose:
                print('values for the scan are (in mm):', scan_pos)

            return scan_pos
        else:
            NotImplementedError('multiple dimensional scans not yet implemented')

    def gaussian(self, x, noise, amp, center, width):
        return (noise + amp * np.exp(-1.0 * (np.square((x - center)) / (2 * (width ** 2)))))

    def fit_gaussian(self):
        noise_guess = np.min(self.data['counts'])
        amplitude_guess = np.max(self.data['counts']) - noise_guess
        center_guess = np.mean(self.data['positions'])
        width_guess = np.std(self.data['positions'])

        p2 = [noise_guess, amplitude_guess, center_guess, width_guess]

        pos_of_max = None

        print('trying to fit the gaussian!')

        try:
            p2, success = sp.optimize.curve_fit(self.gaussian, self.data['positions'],
                                                self.data['counts'], p0=p2,
                                                bounds=([0, [np.inf, np.inf, 100., 100.]]), max_nfev=2000)

            print('p2', p2)
            print('success', success)

            pos_of_max = p2[2]

            self.log('Found fit parameters: ' + str(p2))
        except (ValueError, RuntimeError):
            self.log('Could not converge to fit parameters')

        return pos_of_max, p2

    def _function(self):

        # get the relevant instrument.
        scan_instr = self._get_instr()

        # get positions for the scan.
        scan_pos = self._get_scan_positions()

        # data structure
        self.data = {'counts': deque()}
        self.positions = {'positions': deque()}

        # place for fit parameters
        self.data['fit_parameters'] = [0, 0, 0, 0]
        self.data['positions'] = scan_pos

        # loop over scan positions and call the scripts
        for index in range(0, self.settings['num_points']):
            if self._abort:
                break

            new_pos = float(scan_pos[0][index])
            scan_instr.settings['position'] = new_pos # update the position setting of the instrument
            scan_instr.set_position() # actually move the instrument to that location. If this is not within the safety
                                      # limits of the instruments, it will not actually move and say so in the log

            # track to the NV if it's time to
            if index % self.settings['track_n_pts'] == 0:
                if self.settings['use_autofocus']:
                    self.scripts['autofocus'].run()
                if self.settings['track_to_nv']:
                    self.scripts['find_nv'].run()

            # run daq_read_counter or the relevant script to get fluorescence
            self.scripts['daq_read_counter'].run()
            time.sleep(self.settings['time_per_pt'])
            self.scripts['daq_read_counter'].stop()

            # add to output structures which will be plotted
            data = self.scripts['daq_read_counter'].data['counts']
            self.data['counts'].append(np.mean(data[3:])*2)
            self.positions['positions'].append(new_pos)

            self.progress = index*100./self.settings['num_points']
            self.updateProgress.emit(int(self.progress))

        # clean up data, as in daq_read_counter
        self.data['counts'] = list(self.data['counts'])

        # attempt to fit
        pos_of_max, self.data['fit_parameters'] = self.fit_gaussian()
        if pos_of_max:
            print('found maximum fluorescence position at: ', pos_of_max, ' mm')

    def _plot(self, axes_list, data = None):
        # COMMENT_ME

        if data is None:
            data = self.data

        if data:
            plot_counts_vs_pos(axes_list[0], data['counts'], self.positions['positions'])

        # if the fit has finished plot the result
        if not (np.array_equal(data['fit_parameters'], [0, 0, 0, 0])):
            axes_list[0].plot(data['positions'],
                            self.gaussian(data['positions'], *self.data['fit_parameters']), 'k')

    def _update_plot(self, axes_list):
        update_counts_vs_pos(axes_list[0], self.data['counts'], self.positions['positions'])


class SetServo(Script):
    """
    ServoScan sweeps the position of the automatic translation stages, in 1D scans, and records NV fluorescence
    using Daq_Read_Counter, at each point in the scan.

    We use the NV fluorescence to align a magnetic bias field to the NV axis, generated by a permanent magnet.

    ER 20180606

    """

    _DEFAULT_SETTINGS = [
        Parameter('point',
                  [Parameter('x', 0, float, 'x-coordinate'),
                   Parameter('y', 0, float, 'y-coordinate')
                   ]),
        Parameter('coord_transform',
                  [
                      Parameter('use_galvo_coords', False, bool,
                                'If true, transform the scan coordinates from galvo voltages to servo displacement. This option allows you to define the scan range using galvo scan voltages, which makes it easier to compare ServoScans and GalvoScans'),
                      Parameter('origin',
                                [Parameter('x', 0, float, 'servo x-coords (mm) corresponding to where galvo origin is'),
                                 Parameter('y', 0, float, 'servo y-coords (mm) corresponding to where galvo origin is')
                                 ]),
                      Parameter('scaling',
                                [Parameter('x', 0, float, 'mm/V'),
                                 Parameter('y', 0, float, 'mm/V')
                                 ])]),
        Parameter('daq_type', 'cDAQ', ['PCI', 'cDAQ'], 'Type of daq to use for scan')
    ]

    _INSTRUMENTS = {'XServo': B26KDC001x, 'YServo': B26KDC001y}
    _SCRIPTS = {}

    def transform_coords(self, point):
        """

        :param point: dictionary containing x and y coords in galvo units (V)
        :return: dictionary containing x and y coords in servo units (mm)
        """
        if self.settings['coord_transform']['use_galvo_coords']:
            scale_x = self.settings['coord_transform']['scaling']['x']
            scale_y = self.settings['coord_transform']['scaling']['y']

            offset_x = self.settings['coord_transform']['origin']['x']
            offset_y = self.settings['coord_transform']['origin']['y']

            transformed_coord = {'x': scale_x * point['x'] + offset_x,
                                 'y': scale_y * point['y'] + offset_y}
        else:
            transformed_coord = point
        return transformed_coord



    def _function(self):
        servo_x = self.instruments['XServo']['instance']
        servo_y = self.instruments['YServo']['instance']
        pos = self.transform_coords(self.settings['point'])
        servo_x.settings['position'], servo_y.settings['position'] = pos['x'], pos['y']

        servo_x.set_position()  # actually move the instrument to that location. If this is not within the safety
        servo_y.set_position()  # limits of the instruments, it will not actually move and say so in the log


class ServoScan_2D(Script):
    """
    ServoScan_2D sweeps the position of the automatic translation stages, in 2D scans, and records NV fluorescence
    using Daq_Read_Counter, at each point in the scan.
    We use the NV fluorescence to align a magnetic bias field to the NV axis, generated by a permanent magnet.
    """

    _DEFAULT_SETTINGS = [
        Parameter('track_n_pts', 10, int, 'track every N points'),
        Parameter('outer_loop',
                  [
                      Parameter('scan_axis', 'x', ['x', 'y', 'z'], 'outer loop axis to scan on'),
                      Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
                      Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
                      Parameter('num_points', 100, int, 'number of points in the outer loop')
                  ]),
        Parameter('inner_loop',
                  [
                      Parameter('scan_axis', 'y', ['x', 'y', 'z'], 'inner loop axis to scan on'),
                      Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
                      Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
                      Parameter('num_points', 100, int, 'number of points in the inner loop')
                  ]),
        Parameter('time_per_pt', 0.5, float, 'time to wait at each point (s)'),
        Parameter('use_autofocus', True, bool, 'check to enable autofocus during tracking'),
        Parameter('track_to_nv', False, bool, 'check to use find_nv to track to the NV')
    ]

    _INSTRUMENTS = {'XServo': B26KDC001x, 'YServo': B26KDC001y}
    _SCRIPTS = {'find_nv': FindNv, 'daq_read_counter': Daq_Read_Analog, 'autofocus': AutoFocusDAQMax}

    def _get_instr(self):
        """
        Assigns an instrument relevant to the 1D scan axis.
        """
        if self.settings['outer_loop']['scan_axis'] == 'x':
            outer_instr = self.instruments['XServo']['instance']
        elif self.settings['outer_loop']['scan_axis'] == 'y':
            outer_instr = self.instruments['YServo']['instance']
        elif self.settings['outer_loop']['scan_axis'] == 'z':
            outer_instr = self.instruments['ZServo']['instance']

        if self.settings['inner_loop']['scan_axis'] == 'x':
            inner_instr = self.instruments['XServo']['instance']
        elif self.settings['inner_loop']['scan_axis'] == 'y':
            inner_instr = self.instruments['YServo']['instance']
        elif self.settings['inner_loop']['scan_axis'] == 'z':
            inner_instr = self.instruments['ZServo']['instance']

        if outer_instr == inner_instr:
            AttributeError('pick two different axis for the scan please!')

        return outer_instr, inner_instr

    def _get_scan_positions(self, verbose=True):
        """
        Returns an array of points to go to in the 2D scan.
        """

        min_out = self.settings['outer_loop']['min_pos']
        max_out = self.settings['outer_loop']['max_pos']
        num_out = self.settings['outer_loop']['num_points']

        min_in = self.settings['inner_loop']['min_pos']
        max_in = self.settings['inner_loop']['max_pos']
        num_in = self.settings['inner_loop']['num_points']

        scan_pos_outer = np.linspace(min_out, max_out, num_out)
        scan_pos_inner = np.linspace(min_in, max_in, num_in)

        return scan_pos_outer, scan_pos_inner

    def gaussian(self, x, noise, amp, center, width):
        return (noise + amp * np.exp(-1.0 * (np.square((x - center)) / (2 * (width ** 2)))))

    def fit_gaussian(self):
        noise_guess = np.min(self.data['counts'])
        amplitude_guess = np.max(self.data['counts']) - noise_guess
        center_guess = np.mean(self.data['positions'])
        width_guess = np.std(self.data['positions'])

        p2 = [noise_guess, amplitude_guess, center_guess, width_guess]

        pos_of_max = None

        print('trying to fit the gaussian!')

        try:
            p2, success = sp.optimize.curve_fit(self.gaussian, self.data['positions'],
                                                self.data['counts'], p0=p2,
                                                bounds=([0, [np.inf, np.inf, 100., 100.]]), max_nfev=2000)

            print('p2', p2)
            print('success', success)

            pos_of_max = p2[2]

            self.log('Found fit parameters: ' + str(p2))
        except(ValueError, RuntimeError):
            self.log('Could not converge to fit parameters')

        return pos_of_max, p2

    def _function(self):

        # get the relevant instrument.
        outer_instr, inner_instr = self._get_instr()

        # get positions for the scan.
        scan_pos_outer, scan_pos_inner = self._get_scan_positions()

        # data structure
       # self.data = {'counts': deque()}
        self.data['counts'] = [[0. for x in range(self.settings['outer_loop']['num_points'])] for y in range(self.settings['inner_loop']['num_points'])]

        # place for positions
        self.data['positions_outer'] = scan_pos_outer
        self.data['positions_inner'] = scan_pos_inner

        tot_index = 0

        # loop over scan positions and call the scripts
        for index_out in range(0, self.settings['outer_loop']['num_points']):
            for index_in in range(0, self.settings['inner_loop']['num_points']):

                if self._abort:
                    break

                new_pos = [float(scan_pos_outer[int(index_out)]), float(scan_pos_inner[int(index_in)])]
                self.log('new pos: ' + str(new_pos) + ' mm')
                self.log('set outer instr: '+ str(outer_instr) + ' to ' + str(new_pos[0]) + ' mm')
                self.log('set inner instr: '+ str(inner_instr) + ' to ' + str(new_pos[1]) + ' mm')

                outer_instr.settings['position'] = new_pos[0]  # update the position setting of the instrument
                inner_instr.settings['position'] = new_pos[1]
                outer_instr.set_position()  # actually move the instrument to that location. If this is not within the safety
                inner_instr.set_position()  # limits of the instruments, it will not actually move and say so in the log

                # track to the NV
                if tot_index % self.settings['track_n_pts'] == 0:
                    if self.settings['use_autofocus']:
                      #  raise(NotImplementedError)
                        self.scripts['autofocus'].run()
                    if self.settings['track_to_nv']:
                        self.scripts['find_nv'].run()

                # run daq_read_counter or the relevant script to get fluorescence
                self.scripts['daq_read_counter'].run()
                time.sleep(self.settings['time_per_pt'])
                self.scripts['daq_read_counter'].stop()

                # add to output structures which will be plotted
                if self.scripts['daq_read_counter'].settings['track_laser_power_photodiode1']['on/off'] == True:
                    data = self.scripts['daq_read_counter'].data['normalized_counts']
                else:
                    data = self.scripts['daq_read_counter'].data['counts']
                self.data['counts'][index_in][index_out] = np.mean(data[3:])*2
                # FF: DAQ read counter has a bug where the counts are shown half the actual values, and the first data point always gives zero

                self.progress = tot_index * 100. / (self.settings['inner_loop']['num_points']*self.settings['outer_loop']['num_points'])
                self.updateProgress.emit(int(self.progress))



                tot_index = tot_index + 1

    def plot(self, figure_list):
        super(ServoScan_2D, self).plot([figure_list[0]])

    def _plot(self, axes_list, data=None):
        # COMMENT_ME

        extent = [self.settings['inner_loop']['min_pos'], self.settings['inner_loop']['max_pos'], self.settings['outer_loop']['min_pos'], self.settings['outer_loop']['max_pos']]

        if data is None:
            data = self.data
        if data:
            plot_fluorescence_new(np.array(data['counts']), extent, axes_list[0])

    def _update_plot(self, axes_list):
        extent = [self.settings['inner_loop']['min_pos'], self.settings['inner_loop']['max_pos'], self.settings['outer_loop']['min_pos'], self.settings['outer_loop']['max_pos']]
        update_fluorescence(np.array(self.data['counts']), axes_list[0])


class ServoScan_2D_ESR(Script):
    """
    ServoScan_2D_ESR sweeps the position of the automatic translation stages, in 2D scans, and takes an ESR spectrum at each servo location
    We use the B values extracted from ESRs to align a magnetic bias field to the NV axis, generated by a permanent magnet.
    """

    _DEFAULT_SETTINGS = [
        Parameter('outer_loop',
                  [
                      Parameter('scan_axis', 'x', ['x', 'y', 'z'], 'outer loop axis to scan on'),
                      Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
                      Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
                      Parameter('num_points', 10, int, 'number of points in the outer loop')
                  ]),
        Parameter('inner_loop',
                  [
                      Parameter('scan_axis', 'y', ['x', 'y', 'z'], 'inner loop axis to scan on'),
                      Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
                      Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
                      Parameter('num_points', 10, int, 'number of points in the inner loop')
                  ]),
    ]

    _INSTRUMENTS = {'XServo': B26KDC001x, 'YServo': B26KDC001y, 'ZServo': B26KDC001z}
    _SCRIPTS = {'find_nv': FindNv, 'esr': EsrSimple}

    def _get_instr(self):
        """
        Assigns an instrument relevant to the 1D scan axis.
        """
        if self.settings['outer_loop']['scan_axis'] == 'x':
            outer_instr = self.instruments['XServo']['instance']
        elif self.settings['outer_loop']['scan_axis'] == 'y':
            outer_instr = self.instruments['YServo']['instance']
        elif self.settings['outer_loop']['scan_axis'] == 'z':
            outer_instr = self.instruments['ZServo']['instance']

        if self.settings['inner_loop']['scan_axis'] == 'x':
            inner_instr = self.instruments['XServo']['instance']
        elif self.settings['inner_loop']['scan_axis'] == 'y':
            inner_instr = self.instruments['YServo']['instance']
        elif self.settings['inner_loop']['scan_axis'] == 'z':
            inner_instr = self.instruments['ZServo']['instance']

        if outer_instr == inner_instr:
            AttributeError('pick two different axis for the scan please!')

        return outer_instr, inner_instr

    def _get_scan_positions(self, verbose=True):
        """
        Returns an array of points to go to in the 2D scan.
        """

        min_out = self.settings['outer_loop']['min_pos']
        max_out = self.settings['outer_loop']['max_pos']
        num_out = self.settings['outer_loop']['num_points']

        min_in = self.settings['inner_loop']['min_pos']
        max_in = self.settings['inner_loop']['max_pos']
        num_in = self.settings['inner_loop']['num_points']

        scan_pos_outer = np.linspace(min_out, max_out, num_out)
        scan_pos_inner = np.linspace(min_in, max_in, num_in)

        return scan_pos_outer, scan_pos_inner

    def _function(self):

        # get the relevant instrument.
        outer_instr, inner_instr = self._get_instr()

        # get positions for the scan.
        scan_pos_outer, scan_pos_inner = self._get_scan_positions()

        # data structure
        # NOTE: tricking servoscan structure-- let counts = theta.
        self.data['counts'] = [[0. for x in range(self.settings['outer_loop']['num_points'])] for y in range(self.settings['inner_loop']['num_points'])]
        self.data['Bz'] = [[0. for x in range(self.settings['outer_loop']['num_points'])] for y in range(self.settings['inner_loop']['num_points'])]
        self.data['Bp'] = [[0. for x in range(self.settings['outer_loop']['num_points'])] for y in range(self.settings['inner_loop']['num_points'])]

        # place for positions
        self.data['positions_outer'] = scan_pos_outer
        self.data['positions_inner'] = scan_pos_inner

        tot_index = 0

        # loop over scan positions and call the scripts
        for index_out in range(0, self.settings['outer_loop']['num_points']):
            for index_in in range(0, self.settings['inner_loop']['num_points']):

                if self._abort:
                    break

                new_pos = [float(scan_pos_outer[int(index_out)]), float(scan_pos_inner[int(index_in)])]
                self.log('new pos: ' + str(new_pos) + ' mm')
                self.log('set outer instr: '+ str(outer_instr) + ' to ' + str(new_pos[0]) + ' mm')
                self.log('set inner instr: '+ str(inner_instr) + ' to ' + str(new_pos[1]) + ' mm')

                outer_instr.settings['position'] = new_pos[0]  # update the position setting of the instrument
                inner_instr.settings['position'] = new_pos[1]
                outer_instr.set_position()  # actually move the instrument to that location. If this is not within the safety
                inner_instr.set_position()  # limits of the instruments, it will not actually move and say so in the log

                # track to the NV
                self.scripts['find_nv'].run()
                self.scripts['find_nv'].settings['initial_point'] = self.scripts['find_nv'].data['maximum_point']

                # run esr
                self.scripts['esr'].settings['tag'] = "esr_x_{}_y_{}.".format(index_out, index_in)
                self.scripts['esr'].run()
                fit_params = self.scripts['esr'].data['fit_params']

                # Update data values if fit to 2 peaks successful.
                if (fit_params is not None) and (len(fit_params) == 6):
                    # Extract B field values (from Jan's fitting code)
                    wn = fit_params[4]/(1e9)
                    wp = fit_params[5]/(1e9)
                    gamma = .0027969 #GHz/G
                    D = 2.87
                    Bz = np.sqrt(-(D + wp - 2 * wn) * (D + wn - 2 * wp) * (D + wn + wp)) / (3 * gamma * np.sqrt(3 * D))
                    Bp = np.sqrt(-(2 * D - wp - wn) * (2 * D + 2 * wn - wp) * (2 * D - wn + 2 * wp)) / (3 * gamma * np.sqrt(3 * D))
                    self.data['counts'][index_in][index_out] = np.arctan(Bp / Bz) / np.pi * 180
                    self.data['Bz'][index_in][index_out] = Bz
                    self.data['Bp'][index_in][index_out] = Bp

                self.progress = tot_index * 100. / (self.settings['inner_loop']['num_points']*self.settings['outer_loop']['num_points'])
                self.updateProgress.emit(int(self.progress))

                tot_index = tot_index + 1

    def plot(self, figure_list):
        super(ServoScan_2D_ESR, self).plot([figure_list[0]])

    def _plot(self, axes_list, data=None):
        # COMMENT_ME

        extent = [self.settings['inner_loop']['min_pos'], self.settings['inner_loop']['max_pos'], self.settings['outer_loop']['min_pos'], self.settings['outer_loop']['max_pos']]

        if data is None:
            data = self.data
        if data:
            plot_fluorescence_pos(data['counts'], extent, axes_list[0])

    def _update_plot(self, axes_list):
        extent = [self.settings['inner_loop']['min_pos'], self.settings['inner_loop']['max_pos'], self.settings['outer_loop']['min_pos'], self.settings['outer_loop']['max_pos']]
        update_fluorescence(self.data['counts'], axes_list[0])


class ServoScan_voltage(ServoScan_2D):
    _DEFAULT_SETTINGS = [
        Parameter('outer_loop',
                  [
                      Parameter('scan_axis', 'x', ['x', 'y', 'z'], 'outer loop axis to scan on'),
                      Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
                      Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
                      Parameter('num_points', 100, int, 'number of points in the outer loop')
                  ]),
        Parameter('inner_loop',
                  [
                      Parameter('scan_axis', 'y', ['x', 'y', 'z'], 'inner loop axis to scan on'),
                      Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
                      Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
                      Parameter('num_points', 100, int, 'number of points in the inner loop')
                  ]),
        Parameter('time_per_pt', 0.5, float, 'time to wait at each point (s)'),
        Parameter('statistics', 'min-max', ['min-max', 'mean', 'std'])
    ]

    _INSTRUMENTS = {'XServo': B26KDC001x, 'YServo': B26KDC001y, 'DAQ_voltage': NI9219}
    _SCRIPTS = {'daq_read_ai': Daq_Read_Analog}

    def _function(self):
        # get the relevant instrument.
        outer_instr, inner_instr = self._get_instr()
        print('outer_instr', outer_instr)
        print('inner_instr', inner_instr)

        # get positions for the scan.
        scan_pos_outer, scan_pos_inner = self._get_scan_positions()

        print('scan_pos_outer', scan_pos_outer)
        print('scan_pos_inner', scan_pos_inner)
        # data structure
        self.data['counts'] = [[0. for x in range(self.settings['outer_loop']['num_points'])] for y in range(self.settings['inner_loop']['num_points'])]

        # place for positions
        self.data['positions_outer'] = scan_pos_outer
        self.data['positions_inner'] = scan_pos_inner

        tot_index = 0

        # loop over scan positions and call the scripts
        for index_out in range(0, self.settings['outer_loop']['num_points']):
            for index_in in range(0, self.settings['inner_loop']['num_points']):

                if self._abort:
                    break

                new_pos = [float(scan_pos_outer[int(index_out)]), float(scan_pos_inner[int(index_in)])]
                self.log('new pos: ' + str(new_pos) + ' mm')
                self.log('set outer instr: '+ str(outer_instr) + ' to ' + str(new_pos[0]) + ' mm')
                self.log('set inner instr: '+ str(inner_instr) + ' to ' + str(new_pos[1]) + ' mm')

                outer_instr.settings['position'] = new_pos[0]  # update the position setting of the instrument
                inner_instr.settings['position'] = new_pos[1]
                outer_instr.set_position()  # actually move the instrument to that location. If this is not within the safety
                inner_instr.set_position()  # limits of the instruments, it will not actually move and say so in the log

                # run daq_read_counter or the relevant script to get fluorescence
                self.scripts['daq_read_ai'].run()
                time.sleep(self.settings['time_per_pt'])
                self.scripts['daq_read_ai'].stop()

                data = self.scripts['daq_read_ai'].data['voltage']
                self.daq_data = data
                if data:  # Need this conditional because data might be empty list if abort in the middle of Daq Read Analog
                    if self.settings['statistics'] == 'mean':
                        value_from_data = np.mean(data)
                    elif self.settings['statistics'] == 'std':
                        value_from_data = np.std(data)
                    elif self.settings['statistics'] == 'min-max':
                        value_from_data = np.max(data) - np.min(data)

                self.data['counts'][index_in][index_out] = value_from_data

                self.progress = tot_index * 100. / (self.settings['inner_loop']['num_points']*self.settings['outer_loop']['num_points'])
                self.updateProgress.emit(int(self.progress))
                time.sleep(self.settings['time_per_pt'])
                tot_index = tot_index + 1


class ServoScanFringe(Script):
    """
    ADD DESCRIPTION
    """
    _DEFAULT_SETTINGS = [
        Parameter('point_a',
                  [Parameter('x', 5, float, 'x-coordinate'),
                   Parameter('y', 5, float, 'y-coordinate')
                   ]),
        Parameter('point_b',
                  [Parameter('x', .5, float, 'x-coordinate'),
                   Parameter('y', .5, float, 'y-coordinate')
                   ]),
        Parameter('coord_transform',
                  [
                      Parameter('use_galvo_coords', False, bool,
                                'If true, transform the scan coordinates from galvo voltages to servo displacement. This option allows you to define the scan range using galvo scan voltages, which makes it easier to compare ServoScans and GalvoScans'),
                      Parameter('origin',
                                [Parameter('x', 0, float, 'servo x-coords (mm) corresponding to where galvo origin is'),
                                 Parameter('y', 0, float, 'servo y-coords (mm) corresponding to where galvo origin is')
                                 ]),
                      Parameter('scaling',
                                [Parameter('x', 0, float, 'mm/V'),
                                 Parameter('y', 0, float, 'mm/V')
                                 ])]),
        Parameter('RoI_mode', 'center', ['center', 'corner'], 'mode to calculate region of interest.\n \
                                                           corner: pta and ptb are diagonal corners of rectangle.\n \
                                                           center: pta is center and pta is extend or rectangle'),
        Parameter('num_points',
                  [Parameter('x', 15, int, 'number of x points to scan, if 1 then perform a line scan along the other axis'),
                   Parameter('y', 15, int, 'number of y points to scan, if 1 then perform a line scan along the other axis')
                   ]),
        Parameter('scan_mode', 'book', ['meander', 'book'], 'Meander: scan from left to right, and then back to left for the next line, etc; '
                                                            'Book: always scan from left to right'),
        Parameter('statistics', 'min-max', ['min-max', 'mean', 'std']),
        Parameter('settle_time', 0.02, float, 'time per pt'),
        Parameter('Tracking', [
            Parameter('on/off', False, bool, 'used to turn on tracking'),
            Parameter('every_N', 1, int, 'track every n points')]),
        Parameter('ending_behavior', 'leave_at_corner', ['return_to_start', 'return_to_origin', 'leave_at_corner'],
                  'return to the corn')
    ]

    _INSTRUMENTS = {'XServo': B26KDC001x, 'YServo': B26KDC001y, 'daq_ai': NI9215}
    _SCRIPTS = {}

    def pts_to_extent(self, pta, ptb, roi_mode, use_galvo_coords):
        """
        Args:
            pta: point a
            ptb: point b
            roi_mode:   mode how to calculate region of interest
                        corner: pta and ptb are diagonal corners of rectangle.
                        center: pta is center and ptb is extend or rectangle

        Returns: extend of region of interest [xVmin, xVmax, yVmax, yVmin]
        """
        if roi_mode == 'corner':
            xVmin = min(pta['x'], ptb['x'])
            xVmax = max(pta['x'], ptb['x'])
            yVmin = min(pta['y'], ptb['y'])
            yVmax = max(pta['y'], ptb['y'])
        elif roi_mode == 'center':
            xVmin = pta['x'] - float(ptb['x']) / 2.
            xVmax = pta['x'] + float(ptb['x']) / 2.
            yVmin = pta['y'] - float(ptb['y']) / 2.
            yVmax = pta['y'] + float(ptb['y']) / 2.

        if use_galvo_coords:
            scale_x = self.settings['coord_transform']['scaling']['x']
            scale_y = self.settings['coord_transform']['scaling']['y']

            offset_x = self.settings['coord_transform']['origin']['x']
            offset_y = self.settings['coord_transform']['origin']['y']

            extent = [scale_x * xVmin + offset_x, scale_x * xVmax + offset_x,
                      scale_y * yVmax + offset_y, scale_y * yVmin + offset_y]
        else:
            extent = [xVmin, xVmax, yVmax, yVmin]

        return extent

    def rising_edge(self, data, thresh):
        sign = data >= thresh
        pos = np.where(np.convolve(sign, [1, -1]) == 1)
        return pos[0]

    def check_bounds(self):
        pass

    def _function(self):
        servo_x = self.instruments['XServo']['instance']
        servo_y = self.instruments['YServo']['instance']
        daq_ai = self.instruments['daq_ai']['instance']

        Nx, Ny = self.settings['num_points']['x'], self.settings['num_points']['y']

        self.data = {'point_value': np.zeros((self.settings['num_points']['y'], self.settings['num_points']['x'])),
                     'extent': self.pts_to_extent(self.settings['point_a'], self.settings['point_b'], self.settings['RoI_mode'],
                                                  use_galvo_coords=self.settings['coord_transform']['use_galvo_coords']),
                     'extent_galvo': self.pts_to_extent(self.settings['point_a'], self.settings['point_b'], self.settings['RoI_mode'],
                                                  use_galvo_coords=False)}

        [xVmin, xVmax, yVmax, yVmin] = self.data['extent']

        if xVmin < xVmax:
            self.x_array = np.linspace(xVmin, xVmax, self.settings['num_points']['x'], endpoint=True)
        else:
            self.x_array = np.linspace(xVmax, xVmin, self.settings['num_points']['x'], endpoint=True)

        self.y_array = np.linspace(yVmin, yVmax, self.settings['num_points']['y'], endpoint=True)

        self.data['x_array'] = self.x_array
        self.data['y_array'] = self.y_array

        try:
            self.check_bounds()
        except AttributeError:
            self._abort = True

        self.x_array = self.x_array.tolist()
        self.y_array = self.y_array.tolist()

        time_per_pt = self.settings['settle_time'] * 40 / Nx
        vel = (self.x_array[-1] - self.x_array[0]) / Nx / time_per_pt
        print('Requested scan vel: %.3f mm/s' % vel)

        sample_rate = 10000
        daq_ai.settings['analog_input']['ai0']['sample_rate'] = sample_rate
        daq_ai.settings['analog_input']['ai2']['sample_rate'] = sample_rate

        t_end = time_per_pt * Nx

        servo_x.settings['velocity'] = vel
        servo_x.set_velocity()
        servo_y.settings['velocity'] = 2
        servo_y.set_velocity()

        trigger_config = {'trigger1Mode': 13,
                          'trigger1Polarity': 1,
                          'trigger2Mode': 0,
                          'trigger2Polarity': 1}

        trigger_params = {'triggerStartPositionFwd': self.x_array[0],
                          'triggerIntervalFwd': (self.x_array[-1] - self.x_array[0]) / Nx,
                          'triggerPulseCountFwd': Nx,
                          'triggerStartPositionRev': 0,
                          'triggerIntervalRev': 0,
                          'triggerPulseCountRev': 0,
                          'triggerPulseWidth': 5000,
                          'cycleCount': Ny*Nx}
        assert servo_x.set_trigger_params(trigger_params) == 0

        x_margin = (self.x_array[-1] - self.x_array[0]) / Nx * 2
        t_margin = 0.1 / 0.2 * (self.x_array[-1] - self.x_array[0])

        for i, y in enumerate(self.y_array):
            t_start = time.time()
            if self._abort:
                break
            servo_y.settings['position'] = float(y)
            servo_y.set_position()

            servo_x.settings['velocity'] = 4
            servo_x.set_velocity()
            servo_x.settings['position'] = float(self.x_array[0] - x_margin)
            servo_x.set_position()
            assert servo_x.set_trigger_config(trigger_config) == 0

            task = daq_ai.setup_AI_multi_channel(['ai0', 'ai2'], int((t_end + t_margin) * sample_rate), continuous=False)
            daq_ai.run(task)

            servo_x.settings['velocity'] = vel
            servo_x.set_velocity()
            servo_x.settings['position'] = float(self.x_array[-1] + x_margin)
            servo_x.set_position()

            raw_data, num_read = daq_ai.read(task)
            daq_ai.stop(task)

            data = [float(value) for value in raw_data]
            data_fringes = np.array(data[:int(np.shape(data)[0] / 2)])
            data_trigger = np.array(data[int(np.shape(data)[0] / 2):])

            pixel_edges = self.rising_edge(data_trigger, 3)
            print('Detected %i edges!' % len(pixel_edges))
            pixels = np.split(data_fringes, pixel_edges)[1:]
            if self.settings['statistics'] == 'min-max':
                pixels = [np.max(pixel) - np.min(pixel) for pixel in pixels]
            elif self.settings['statistics'] == 'std-max':
                pixels = [np.std(pixel) for pixel in pixels]
            elif self.settings['statistics'] == 'mean':
                pixels = [np.mean(pixel) for pixel in pixels]
            if xVmin > xVmax:
                pixels = pixels[::-1]
            if len(pixel_edges) == Nx:
                self.data['point_value'][i] = pixels
            else:
                self.log('Warning: measured only %i positions on line Vy=%.2f instead of the requested %i!'
                         % (len(pixel_edges), y, Nx))

            self.progress = float(i+1) / len(self.y_array) * 100
            self.updateProgress.emit(int(self.progress))

            print('Time elapsed %.1f' % (time.time() - t_start))

    def _plot(self, axes_list, data = None):
        """
        Plots the galvo scan image
        Args:
            axes_list: list of axes objects on which to plot the galvo scan on the first axes object
            data: data (dictionary that contains keys image_data, extent) if not provided use self.data
        """

        if data is None:
            data = self.data

        if self.settings['statistics'] == 'std':
            label = ['Fringe scan with Servo Motor', r'V$_x$ [mm]', r'V$_y$ [mm]', 'Fringe STD (V)']
        elif self.settings['statistics'] == 'mean':
            label = ['Fringe scan with Servo Motor', r'V$_x$ [mm]', r'V$_y$ [mm]', 'Fringe mean value (V)']
        elif self.settings['statistics'] == 'min-max':
            label = ['Fringe scan with Servo Motor', r'V$_x$ [mm]', r'V$_y$ [mm]', 'Fringe Vpp (V)']

        plot_fluorescence_new(data['point_value'], data['extent_galvo'], axes_list[0], max_counts=-1, labels=label)

    def _update_plot(self, axes_list):
        """
        updates the galvo scan image
        Args:
            axes_list: list of axes objects on which to plot plots the esr on the first axes object
        """
        update_fluorescence(self.data['point_value'], axes_list[0], -1)


if __name__ == '__main__':
    succeeded, failed, _ = Script.load_and_append({'ServoScan': ServoScan})

    print(succeeded)
